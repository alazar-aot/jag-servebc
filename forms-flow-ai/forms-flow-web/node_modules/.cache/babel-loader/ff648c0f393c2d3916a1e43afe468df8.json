{"ast":null,"code":"import _createForOfIteratorHelper from \"C:\\\\Users\\\\Devin\\\\AOT_Projects\\\\forms-flow-master\\\\forms-flow-ai\\\\forms-flow-web\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\createForOfIteratorHelper.js\";\nimport _toConsumableArray from \"C:\\\\Users\\\\Devin\\\\AOT_Projects\\\\forms-flow-master\\\\forms-flow-ai\\\\forms-flow-web\\\\node_modules\\\\@babel\\\\runtime\\\\helpers\\\\esm\\\\toConsumableArray.js\";\n\n/* istanbul ignore file */\nimport { httpGETRequest, httpPUTRequest } from \"../httpRequestHandler\";\nimport { setDashboards, dashboardErrorHandler, setGroups, updateErrorHandler, hideUpdateError } from \"../../actions/dashboardActions\";\nimport API from '../endpoints/index';\nimport { replaceUrl } from \"../../helper/helper\";\nexport var updateGroup = function updateGroup(data) {\n  var apiUpdateGroup = replaceUrl(API.UPDATE_GROUPS, \"<groupId>\", data.group);\n  return function (dispatch) {\n    httpPUTRequest(apiUpdateGroup, {\n      dashboards: data.dashboards\n    }).then(function (res) {\n      if (res.data) {\n        dispatch(fetchdashboards());\n        dispatch(fetchGroups());\n      } else {\n        dispatch(updateErrorHandler(\"Update Failed\"));\n        setTimeout(function () {\n          dispatch(hideUpdateError());\n        }, 2000);\n      }\n    }).catch(function (error) {\n      dispatch(updateErrorHandler(error));\n      setTimeout(function () {\n        dispatch(hideUpdateError());\n      }, 2000);\n    });\n  };\n};\nexport var fetchdashboards = function fetchdashboards() {\n  return function (dispatch) {\n    httpGETRequest(API.GET_DASHBOARDS).then(function (res) {\n      if (res.data) {\n        dispatch(setDashboards(res.data));\n      } else {\n        dispatch(dashboardErrorHandler(\"No dashboards found\"));\n      }\n    }).catch(function (error) {\n      var _error$response;\n\n      if (error !== null && error !== void 0 && (_error$response = error.response) !== null && _error$response !== void 0 && _error$response.data) {\n        dispatch(dashboardErrorHandler(error.response.data));\n      } else {\n        dispatch(dashboardErrorHandler(\"Failed to fetch dashboards\"));\n      }\n    });\n  };\n};\nexport var fetchGroups = function fetchGroups() {\n  return function (dispatch) {\n    httpGETRequest(API.GET_GROUPS).then(function (res) {\n      if (res.data) {\n        var cleanedGroups = cleanGroups(res.data);\n        dispatch(setGroups(cleanedGroups));\n      } else {\n        dispatch(dashboardErrorHandler(\"No groups found\"));\n      }\n    }).catch(function (error) {\n      var _error$response2;\n\n      if (error !== null && error !== void 0 && (_error$response2 = error.response) !== null && _error$response2 !== void 0 && _error$response2.data) {\n        dispatch(dashboardErrorHandler(error.response.data));\n      } else {\n        dispatch(dashboardErrorHandler(\"Failed to fetch groups\"));\n      }\n    });\n  };\n}; // dashboards property should be cleaned before updating the store\n\nexport var cleanGroups = function cleanGroups(groups) {\n  if ((groups === null || groups === void 0 ? void 0 : groups.length) === 0) {\n    return groups;\n  }\n\n  var newGroups = _toConsumableArray(groups);\n\n  var _iterator = _createForOfIteratorHelper(newGroups),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var group = _step.value;\n      group.dashboards = getCleanedDashboards(group.dashboards);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return newGroups;\n}; // since the data we need is not a valid json / or stringified json, the approach taken \n// to extract the data is string manipulation and create the objects from the extracted information.\n// input format --> dashboards: [\n//    \"[{'5': 'Hello'}, {'4': 'testathira'}, {'6': 'New Business License Application'}, {'8': 'Sentiment Analysis'}, {'7': 'Freedom Of Information Form'}, {'3': 'test'}, {'12': 'dashboard4'}]\"\n//]\n//output format --> dashboards:[\n//  {'5': 'Hello'}, {'4': 'testathira'}, {'6': 'New Business License Application'}, {'8': 'Sentiment Analysis'}, {'7': 'Freedom Of Information Form'}, {'3': 'test'}, {'12': 'dashboard4'}\n//]\n\nexport var getCleanedDashboards = function getCleanedDashboards(dashboards) {\n  // possible edge case \n  if (dashboards === null || dashboards.length === 0) {\n    return [];\n  }\n\n  dashboards = dashboards[0];\n  dashboards = dashboards.substring(1, dashboards.length - 1);\n  dashboards = dashboards.split(\",\");\n  var newdash = [];\n\n  var _iterator2 = _createForOfIteratorHelper(dashboards),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var _substrArray$3;\n\n      var str = _step2.value;\n\n      // avoiding unwanted entries\n      if (str === \"{}\" || str === \"\") {\n        // skip the remaining process for above conditions\n        continue;\n      }\n\n      var substr = str.substring(1, str.length - 1); // to identify possible object patterns and to extract the key and value splits the string based on \":\" seperator\n\n      var substrArray = substr.split(\":\");\n      var newObj = {};\n      var id = null; // The data given by the api seems to have consistent patterns which are essential for \n      // a non fragile implmentation. All the entries after the first entry in the string representation of the array have\n      // space before the entry, so need to handle the two cases\n\n      if (dashboards.indexOf(str) === 0) {\n        var _substrArray$;\n\n        id = Number((_substrArray$ = substrArray[0]) === null || _substrArray$ === void 0 ? void 0 : _substrArray$.substring(1, substrArray[0].length - 1));\n      } else {\n        var _substrArray$2;\n\n        id = Number((_substrArray$2 = substrArray[0]) === null || _substrArray$2 === void 0 ? void 0 : _substrArray$2.substring(2, substrArray[0].length - 1));\n      }\n\n      newObj[id] = (_substrArray$3 = substrArray[1]) === null || _substrArray$3 === void 0 ? void 0 : _substrArray$3.substring(2, substrArray[1].length - 1);\n      newdash.push(newObj);\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return newdash;\n};","map":{"version":3,"sources":["C:/Users/Devin/AOT_Projects/forms-flow-master/forms-flow-ai/forms-flow-web/src/apiManager/services/dashboardsService.js"],"names":["httpGETRequest","httpPUTRequest","setDashboards","dashboardErrorHandler","setGroups","updateErrorHandler","hideUpdateError","API","replaceUrl","updateGroup","data","apiUpdateGroup","UPDATE_GROUPS","group","dispatch","dashboards","then","res","fetchdashboards","fetchGroups","setTimeout","catch","error","GET_DASHBOARDS","response","GET_GROUPS","cleanedGroups","cleanGroups","groups","length","newGroups","getCleanedDashboards","substring","split","newdash","str","substr","substrArray","newObj","id","indexOf","Number","push"],"mappings":"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","sourcesContent":[" /* istanbul ignore file */\r\nimport { httpGETRequest,httpPUTRequest } from \"../httpRequestHandler\";\r\nimport { setDashboards,dashboardErrorHandler,setGroups,updateErrorHandler, hideUpdateError } from \"../../actions/dashboardActions\";\r\nimport API from '../endpoints/index'\r\nimport { replaceUrl } from \"../../helper/helper\";\r\n\r\nexport const updateGroup = (data)=>{\r\n  const apiUpdateGroup = replaceUrl(\r\n    API.UPDATE_GROUPS,\r\n    \"<groupId>\",\r\n    data.group\r\n  );\r\n  return (dispatch) => {\r\n    httpPUTRequest(apiUpdateGroup,{dashboards:data.dashboards})\r\n    .then((res)=>{\r\n      if(res.data){\r\n        dispatch(fetchdashboards());\r\n        dispatch(fetchGroups())\r\n      }else{\r\n        dispatch(updateErrorHandler(\"Update Failed\"));\r\n        setTimeout(() => {\r\n          dispatch(hideUpdateError());\r\n        }, 2000);\r\n      }\r\n    })\r\n    .catch((error)=>{\r\n      dispatch(updateErrorHandler(error));\r\n      setTimeout(() => {\r\n        dispatch(hideUpdateError());\r\n      }, 2000);\r\n    })\r\n  }\r\n}\r\n\r\nexport const fetchdashboards = ()=>{\r\n    return (dispatch) => {\r\n        httpGETRequest(API.GET_DASHBOARDS)\r\n          .then((res) => {\r\n            if (res.data) {\r\n              dispatch(setDashboards(res.data));\r\n            } else {\r\n              dispatch(dashboardErrorHandler(\"No dashboards found\"));\r\n            }\r\n          })\r\n          .catch((error) => {\r\n            if(error?.response?.data){\r\n              dispatch(dashboardErrorHandler(error.response.data));\r\n            }else{\r\n              dispatch(dashboardErrorHandler(\"Failed to fetch dashboards\"));\r\n            }\r\n          });\r\n      };\r\n}\r\n\r\nexport const fetchGroups = ()=>{\r\n    return (dispatch) => {\r\n        httpGETRequest(API.GET_GROUPS)\r\n          .then((res) => {\r\n            if (res.data) {\r\n              const cleanedGroups = cleanGroups(res.data);\r\n                dispatch(setGroups(cleanedGroups))    \r\n            } else {\r\n              dispatch(dashboardErrorHandler(\"No groups found\"));\r\n            }\r\n          })\r\n          .catch((error) => {\r\n            if(error?.response?.data){\r\n              dispatch(dashboardErrorHandler(error.response.data));\r\n            }else{\r\n              dispatch(dashboardErrorHandler(\"Failed to fetch groups\"));\r\n            }\r\n          });\r\n      };\r\n  \r\n}\r\n\r\n// dashboards property should be cleaned before updating the store\r\nexport const cleanGroups = (groups)=>{\r\n\r\n    if(groups?.length === 0){\r\n      return groups;\r\n    }\r\n\r\n    let newGroups = [...groups];\r\n\r\n    for(let group of newGroups){\r\n        group.dashboards = getCleanedDashboards(group.dashboards)\r\n    }\r\n\r\n    return newGroups;\r\n\r\n}\r\n\r\n// since the data we need is not a valid json / or stringified json, the approach taken \r\n// to extract the data is string manipulation and create the objects from the extracted information.\r\n\r\n// input format --> dashboards: [\r\n//    \"[{'5': 'Hello'}, {'4': 'testathira'}, {'6': 'New Business License Application'}, {'8': 'Sentiment Analysis'}, {'7': 'Freedom Of Information Form'}, {'3': 'test'}, {'12': 'dashboard4'}]\"\r\n//]\r\n//output format --> dashboards:[\r\n//  {'5': 'Hello'}, {'4': 'testathira'}, {'6': 'New Business License Application'}, {'8': 'Sentiment Analysis'}, {'7': 'Freedom Of Information Form'}, {'3': 'test'}, {'12': 'dashboard4'}\r\n//]\r\nexport const getCleanedDashboards = (dashboards)=>{\r\n  // possible edge case \r\n  if( dashboards === null || dashboards.length === 0 ){\r\n    return []\r\n  }\r\n\r\n    dashboards = dashboards[0];\r\n    dashboards = dashboards.substring(1,dashboards.length-1);\r\n    dashboards = dashboards.split(\",\");\r\n\r\n  let newdash = [];\r\n\r\n  for(let str of dashboards){\r\n    // avoiding unwanted entries\r\n    if(str === \"{}\" || str === \"\"){\r\n      // skip the remaining process for above conditions\r\n      continue;\r\n    }\r\n      let substr = str.substring(1,str.length-1);\r\n          // to identify possible object patterns and to extract the key and value splits the string based on \":\" seperator\r\n      let substrArray = substr.split(\":\");\r\n      let newObj = {};\r\n      let id = null;\r\n\r\n    // The data given by the api seems to have consistent patterns which are essential for \r\n    // a non fragile implmentation. All the entries after the first entry in the string representation of the array have\r\n    // space before the entry, so need to handle the two cases\r\n\r\n      if(dashboards.indexOf(str) === 0){\r\n        id = Number(substrArray[0]?.substring(1,substrArray[0].length-1));\r\n\r\n      }else{\r\n        id = Number(substrArray[0]?.substring(2,substrArray[0].length-1));\r\n\r\n      }\r\n      newObj[id] = substrArray[1]?.substring(2,substrArray[1].length-1);\r\n      newdash.push(newObj)\r\n  }\r\n\r\n  return newdash;\r\n}\r\n\r\n"]},"metadata":{},"sourceType":"module"}